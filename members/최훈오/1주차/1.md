# 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/250136

# 1. 내 풀이 - 1

```jsx
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

function solution(land) {
	const answer = []
	const n = land.length
	const m = land[0].length
	let visited = Array.from(Array(n), () => Array(m).fill(0))

	const bfs = (x, y) => {
		let count = 1
		const queue = [[x, y]]
		visited[x][y] = 1
		while (queue.length) {
			const [curX, curY] = queue.shift()
			for (let i = 0; i < 4; i++) {
				const nx = dx[i] + curX
				const ny = dy[i] + curY
				if (
					nx >= 0 &&
					nx < n &&
					ny >= 0 &&
					ny < m &&
					land[nx][ny] &&
					!visited[nx][ny]
				) {
					queue.push([nx, ny])
					visited[nx][ny] = 1
					count += 1
				}
			}
		}
		return count
	}

	for (let i = 0; i < m; i++) {
		let sum = 0
		visited = Array.from(Array(n), () => Array(m).fill(0))
		for (let j = 0; j < n; j++) {
			if (land[j][i] && !visited[j][i]) {
				sum += bfs(j, i)
			}
		}
		answer.push(sum)
	}
	return Math.max(...answer)
}
```

### 결과

정확성 테스트는 모두 통과했지만, 효율성 테스트는 6개 중 5개를 실패했다.

### 풀이 방법

bfs를 이용하였다.

열을 기준으로 아래로 이동하면서 bfs를 통해 합을 구해줬다.

다만 열을 바꿀때마다 `visited` 2차원 배열을 매번 선언해야 하고, 구해놨던 석유정보도 다시 구해야하기 때문에 시간초과가 난듯하다.

# 1. 내 풀이 - 2

```jsx
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

function solution(land) {
	const answer = []
	const n = land.length
	const m = land[0].length
	let visited = Array.from(Array(n), () => Array(m).fill(0))

	const bfs = (x, y) => {
		let count = 1
		const queue = [[x, y]]
		const maxArr = [[x, y]]
		visited[x][y] = 1
		while (queue.length) {
			const [curX, curY] = queue.shift()
			for (let i = 0; i < 4; i++) {
				const nx = dx[i] + curX
				const ny = dy[i] + curY
				if (
					nx >= 0 &&
					nx < n &&
					ny >= 0 &&
					ny < m &&
					land[nx][ny] &&
					!visited[nx][ny]
				) {
					queue.push([nx, ny])
					maxArr.push([nx, ny])
					visited[nx][ny] = 1
					count += 1
				}
			}
		}
		maxArr.forEach(([mx, my]) => {
			land[mx][my] = count
		})
	}
	for (let i = 0; i < n; i++) {
		for (let j = 0; j < m; j++) {
			if (land[i][j] && !visited[i][j]) {
				bfs(i, j)
			}
		}
	}

	for (let i = 0; i < m; i++) {
		let sum = 0
		for (let j = 0; j < n - 1; j++) {
			if (!land[j + 1][i]) {
				sum += land[j][i]
			}
		}
		sum += land[n - 1][m - 1]
		answer.push(sum)
	}
	return Math.max(...answer)
}
```

### 결과

정확성 테스트가 3개만 통과하였다.

### 풀이 방법

미리 bfs를 통해 석유정보를 모두 `land`에 저장한다. 대신 land에 들어가는 정보는 인접한 최대 석유량을 미리 넣어놨다.

이후 이전 풀이와 똑같이 열마다 행을 아래로 움직이면서 더하기만 하면 될 줄 알았는데 석유정보가 붙어있는 경우 처리하기가 까다로워진다. 이 부분을 어떻게 하면 될 것 같기도한데 경우의수가 좀 많아보여서 포기하였다.

# 2. 다른 사람 풀이

> 두번째 풀이로도 안풀려서 블로그를 참조했습니다.

```jsx
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

function solution(land) {
	let max = 0
	const n = land.length
	const m = land[0].length
	let visited = Array.from(Array(n), () => Array(m).fill(0))
	const oilMap = new Map()
	let oilIndex = 1

	const bfs = (x, y) => {
		let count = 1
		const queue = [[x, y]]
		visited[x][y] = oilIndex
		while (queue.length) {
			const [curX, curY] = queue.shift()
			for (let i = 0; i < 4; i++) {
				const nx = dx[i] + curX
				const ny = dy[i] + curY
				if (
					nx >= 0 &&
					nx < n &&
					ny >= 0 &&
					ny < m &&
					land[nx][ny] &&
					!visited[nx][ny]
				) {
					queue.push([nx, ny])
					visited[nx][ny] = oilIndex
					count += 1
				}
			}
		}
		oilMap[oilIndex++] = count
		return count
	}

	for (let i = 0; i < n; i++) {
		for (let j = 0; j < m; j++) {
			if (!visited[i][j] && land[i][j] > 0) {
				bfs(i, j)
			}
		}
	}

	for (let i = 0; i < m; i++) {
		let sum = 0
		const set = new Set()
		for (let j = 0; j < n; j++) {
			if (visited[j][i] !== 0) {
				set.add(visited[j][i])
			}
		}
		set.forEach((item) => {
			sum += oilMap[item]
		})

		max = Math.max(sum, max)
	}
	return max
}
```

### 풀이 방법

우선 bfs를 처음부터 끝까지 돌면서 `map`자료구조에 순서:덩어리개수로 저장한다. 테스트케이스 1의 경우 `{0:7, 1:8, 2:2}`로 저장한다. 이때 주의할점은 `visited` 방문 배열에 석유 시추 순서를 저장한다.(map의 key)

이후 열마다 행을 이동하며 방문한곳(석유가 있는곳)이면 `set`자료구조에 `visited`정보를 넣는다.즉 석유 시추순서를 넣는다. 한 열을 돌았으면 `set`의 모든 value를 더한다. 만약 행을 옮기면서 다른 덩어리를 만날경우 set자료구조에 다른 visited 정보가 담기므로 다른 덩어리에 대한 합을 구할 수 있다.

이후 최댓값을 반환하면 끝

## 배운 점

똑같은 석유정보 개수라도 다른 행열에 있으면 구분해야하는데 이때 `Set`자료구조로 해결한다는게 좀 놀라웠다.. 이해가 됐는데도 신기한 느낌이고 접근 방법이 아예 달라서 더 어렵게 느껴진다.

### 느낀 점

그냥 보기에는 bfs로 간단하게 풀릴줄 알았는데 어렵다.. 시간 초과가 난 뒤에 왜 틀린지는 알았는데 개선할 방법이 안보여서 다른 풀이로도 해봤는데 잘 안풀려서 당황했다. 일단 문제를 푸는것보다 풀기전에 생각을 많이 하자.
